<!doctype html>
<html lang="el">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Chrome Dino - JavaScript</title>
  <style>
    :root{--bg:#fff;--ground:#444;--dino:#222;--ob:#222;--score:#111}
    html,body{height:100%;margin:0;font-family:Arial,Helvetica,sans-serif;background:var(--bg);display:flex;align-items:center;justify-content:center}
    #gameWrap{width:900px;max-width:95%;}
    canvas{display:block;width:100%;height:auto;background:linear-gradient(#fff,#fff);border:1px solid #eee;box-shadow:0 8px 30px rgba(0,0,0,0.05)}
    .info{margin-top:10px;display:flex;justify-content:space-between;align-items:center;color:#666}
    .btn{background:#222;color:#fff;padding:6px 10px;border-radius:6px;border:none;cursor:pointer}
    @media (max-width:420px){ .info{font-size:14px} }
  </style>
</head>
<body>
  <div id="gameWrap">
    <canvas id="game" width="900" height="200"></canvas>
    <div class="info">
      <div>Χρησιμοποιήστε Space ή Πάνω για άλμα — Κάτω για κάθισμα / Touch για κινητό</div>
      <div><button id="restart" class="btn">Ξεκίνα / Επανεκίνηση</button></div>
    </div>
  </div>

<script>
// Minimal Chrome Dino-like game in JavaScript
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const DPR = window.devicePixelRatio || 1;
  const W = canvas.width;
  const H = canvas.height;
  canvas.width = W * DPR;
  canvas.height = H * DPR;
  canvas.style.width = W + 'px';
  canvas.style.height = H + 'px';
  ctx.scale(DPR, DPR);

  // Game state
  let speed = 6;
  let gravity = 0.6;
  let gameOver = false;
  let score = 0;
  let distance = 0;
  let highScore = 0;

  // Dino
  const dino = {
    x: 40, y: H - 48, w: 44, h: 44, vy:0, grounded:true, duck:false
  };

  // Obstacles
  const obstacles = [];
  const birds = [];
  const clouds = [];
  let obstacleTimer = 0;
  let cloudTimer = 0;

  function reset(){
    speed = 6; gravity = 0.6; gameOver=false; score=0; distance=0; obstacles.length=0; birds.length=0; clouds.length=0; dino.y = H - 48; dino.vy=0; dino.grounded=true; dino.duck=false; obstacleTimer = 0; cloudTimer=0;
  }

  function spawnObstacle(){
    // choose cactus or bird
    if (Math.random() < 0.22) {
      // bird
      birds.push({x: W+10, y: H-100 - Math.random()*40, w: 34, h: 24});
    } else {
      // cactus - small, medium, large
      const sizes = [{w:18,h:36},{w:26,h:44},{w:36,h:52}];
      const s = sizes[Math.floor(Math.random()*sizes.length)];
      obstacles.push({x: W+10, y: H - s.h - 4, w: s.w, h: s.h});
    }
  }

  function spawnCloud(){
    clouds.push({x: W+10, y: 20 + Math.random()*60, w: 46, h: 16, speed: 0.7 + Math.random()*0.8});
  }

  function update(){
    if (gameOver) return;

    // increase difficulty gradually
    distance += speed/60;
    if (distance > 100) speed = 6 + Math.floor(distance/1000);
    score = Math.floor(distance);
    if (score > highScore) highScore = score;

    // Dino physics
    if (!dino.grounded){
      dino.vy += gravity;
      dino.y += dino.vy;
      if (dino.y >= H - 48) { dino.y = H-48; dino.vy = 0; dino.grounded = true; }
    }

    // Obstacles movement
    for (let i = obstacles.length-1; i>=0; i--){
      obstacles[i].x -= speed;
      if (obstacles[i].x + obstacles[i].w < -20) obstacles.splice(i,1);
      else if (collides(obstacles[i], dino)) { hit(); }
    }
    for (let i = birds.length-1; i>=0; i--){
      birds[i].x -= speed + 1;
      if (birds[i].x + birds[i].w < -20) birds.splice(i,1);
      else if (collides(birds[i], dino)) { hit(); }
    }
    for (let i = clouds.length-1; i>=0; i--){
      clouds[i].x -= clouds[i].speed;
      if (clouds[i].x + clouds[i].w < -40) clouds.splice(i,1);
    }

    // spawn logic
    obstacleTimer -= 1 + Math.random()*0.6;
    if (obstacleTimer <= 0){
      spawnObstacle();
      obstacleTimer = 60 + Math.random()*80 - Math.min(distance/5,40);
    }
    cloudTimer -= 1;
    if (cloudTimer <= 0){ spawnCloud(); cloudTimer = 120 + Math.random()*200; }
  }

  function collides(obj, player){
    // define player box smaller when ducking
    const py = player.duck ? (player.y + 22) : player.y;
    const ph = player.duck ? (player.h/2) : player.h;
    return !(obj.x > player.x + player.w - 6 || obj.x + obj.w - 6 < player.x || obj.y > py + ph || obj.y + obj.h < py);
  }

  function hit(){
    gameOver = true;
  }

  function draw(){
    // clear
    ctx.clearRect(0,0,W,H);

    // ground
    ctx.fillStyle = '#efefef';
    ctx.fillRect(0, H-4, W, 4);
    ctx.strokeStyle = '#bdbdbd';
    ctx.beginPath();
    ctx.moveTo(0, H-4.5);
    ctx.lineTo(W, H-4.5);
    ctx.stroke();

    // clouds
    ctx.fillStyle = '#e9e9e9';
    clouds.forEach(c => {
      roundRect(ctx, c.x, c.y, c.w, c.h, 8, true);
    });

    // dino (simple pixel-like)
    ctx.save();
    ctx.translate(dino.x, dino.y);
    if (dino.duck){
      // draw lower rectangle
      roundRect(ctx, 0, 22, dino.w, dino.h/2, 4, true);
    } else {
      // body
      roundRect(ctx, 0, 0, dino.w, dino.h, 6, true);
      // eye
      ctx.fillStyle = '#fff';
      ctx.fillRect(28, 10, 6, 6);
      ctx.fillStyle = '#222';
      ctx.fillRect(30, 12, 2, 2);
    }
    ctx.restore();

    // obstacles
    ctx.fillStyle = '#222';
    obstacles.forEach(o => {
      roundRect(ctx, o.x, o.y, o.w, o.h, 4, true);
    });
    // birds
    birds.forEach(b => {
      // simple bird: body + wing
      ctx.fillStyle = '#222';
      roundRect(ctx, b.x, b.y, b.w, b.h, 4, true);
      ctx.fillRect(b.x-6, b.y+6, 10, 4);
    });

    // score
    ctx.fillStyle = '#222';
    ctx.font = '14px monospace';
    ctx.fillText('Score: ' + score, W - 140, 24);
    ctx.fillText('High: ' + highScore, W - 140, 42);

    // game over
    if (gameOver){
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(W/2 - 140, H/2 - 36, 280, 72);
      ctx.fillStyle = '#fff';
      ctx.font = '18px Arial';
      ctx.fillText('Game Over', W/2 - 48, H/2 - 6);
      ctx.font = '14px Arial';
      ctx.fillText('Πατήστε Ξεκίνα ή Space για επανεκκίνηση', W/2 - 150, H/2 + 14);
    }
  }

  function roundRect(ctx, x, y, w, h, r, fill){
    if (typeof r === 'undefined') r = 5;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    if (fill) ctx.fill(); else ctx.stroke();
  }

  // main loop
  let last = 0;
  function loop(ts){
    update();
    draw();
    last = ts;
    requestAnimationFrame(loop);
  }

  // controls
  function jump(){
    if (gameOver){ reset(); return; }
    if (dino.grounded){ dino.vy = -12; dino.grounded = false; dino.duck = false; }
  }
  function duck(on){
    if (on){ dino.duck = true; }
    else dino.duck = false;
  }

  window.addEventListener('keydown', e => {
    if (e.code === 'Space' || e.code === 'ArrowUp'){ e.preventDefault(); jump(); }
    if (e.code === 'ArrowDown'){ e.preventDefault(); duck(true); }
  });
  window.addEventListener('keyup', e => { if (e.code === 'ArrowDown'){ duck(false); } if (e.code === 'Space' && gameOver){ reset(); } });

  // touch support: tap to jump, swipe down to duck
  let touchStartY = null;
  canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    const t = e.touches[0];
    touchStartY = t.clientY;
    jump();
  }, {passive:false});
  canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    const t = e.touches[0];
    if (touchStartY !== null && t.clientY - touchStartY > 30) duck(true);
  }, {passive:false});
  canvas.addEventListener('touchend', e => { duck(false); touchStartY = null; }, {passive:false});

  document.getElementById('restart').addEventListener('click', () => { reset(); });

  // Start
  reset();
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>
